/**
 * @author Seth Traman
 * @date   2019 03 04
 *
 * @file   Tracer.comp
 * @brief  Updated raytracing compute shader
 */



#version 460

#extension GL_ARB_separate_shader_objects : enable



/**
 * @struct Camera
 *
 * @brief Represents the viewport which is recieving light from the scene
 */
struct Camera
{
	/// @brief Position of the camera in world-space
	vec3 pos;

	/// @brief Normalized direction vector that the camera is viewing
	vec3 dir;

	/// @brief Normalized right-facing direction relative to view direction
	vec3 right;

	/// @brief Normalized up-facing direction relative to view direction
	vec3 up;
};

/**
 * @struct Ray
 *
 * @brief A three-dimentional half-line which may intersect with other geometric primitives
 */
struct Ray
{
	/// @brief Position where the ray originates in world-space
	vec3 origin;

	/// @brief Normalized direction vector that the ray is shooting
	vec3 dir;
};

const uint MAT_TYPE_DIFFUSE = 0; // Diffuse and specular
const uint MAT_TYPE_REFLECT = 1; // Behaves like a mirror

struct Material
{
	/// @brief Base color of object
	vec3 albedo;

	/// @brief Color emissed by object regardless of lighting
	vec3 emissive;

	/// @brief Determines how object-light interactions should be handled
	uint type;
};

/**
 * @struct Intersection
 *
 * @brief Information about intersection between a ray and a geometric primitive
 *
 * @see Ray
 */
struct Intersection
{
	Material mat;

	/// @brief Distance from ray origin which intersection occured
	float t;

	/// @brief Position of ray intersection in world-space
	vec3 P;

	/// @brief Normal of surface patch which ray collided with
	vec3 N;
};

/**
 * @struct Light
 *
 * @brief Point light, creator of photons, illuminator of worlds
 */
struct Light
{
	/// @brief Position of light in world-space
	vec3 P;

	/// @brief RGB color of photons emitted from light
	vec3 color;
};

/**
 * @struct Sphere
 *
 * @brief Like a ball, but somehow rounder
 */
struct Sphere
{
	Material mat;

	/// @brief Position of sphere in world-space
	vec3 P;

	/// @brief Radius of the sphere
	float r;
};

/**
 * @struct Plane
 *
 * @brief Flatt primitive which stretches into the   v o i d
 */
struct Plane
{
	Material mat;

	vec3 N;

	float len;
};



/////
// Shader Communication
/////



layout (local_size_x = 16, local_size_y = 16) in;

layout (set = 0, binding = 0, rgba8) uniform writeonly image2D render_target;

layout (push_constant) uniform FrameData
{
	/// @brief Width-height ratio of rendering media
	float aspect_ratio;

	float seed;

	/// @brief Position of the light source in world space
	vec3 light_pos;

	/// @brief Camera viewport object
	/// @see Camera
	Camera camera;
};



/////
// Constants
/////



const float PI      = 3.14159265359;
const float EPSILON = 1e-3;

const float DEPTH   = 4;
const float SAMPLES = 4;

const uint LIGHT_COUNT  = 1;
const uint SPHERE_COUNT = 3;
const uint PLANE_COUNT  = 1;

const Material matte_white = { vec3(1.0, 1.0, 1.0), vec3(0.0), MAT_TYPE_DIFFUSE };
const Material matte_blue  = { vec3(0.25, 0.25, 0.75), vec3(0.0), MAT_TYPE_DIFFUSE };

const Material mirror = { vec3(1.0, 0.5, 0.5), vec3(0.0),  MAT_TYPE_REFLECT };
const Material light  = { vec3(1.0, 1.0, 1.0), vec3(48.0), MAT_TYPE_DIFFUSE };

Sphere spheres[SPHERE_COUNT] =
{
	{ mirror,  vec3(72.0, 16.0, 12.0), 16.0 },
	{ light, vec3(0.0, 96.0, 0.0), 12.0 },
	{ matte_blue,  vec3(-12.0, 12.0, -72.0), 12.0 }
};

Plane planes[PLANE_COUNT] =
{
	{ matte_white, vec3(0.0, 1.0, 0.0), 0.0 },
};



/////
// Functions
/////


float rand(in vec2 co)
{
	return fract(sin(dot(co + seed, vec2(12.9898, 78.233))) * 43758.5453);
}

float rand_salt = 0.0;

float rand() { return fract(sin(++rand_salt) * 43758.5453123); }

float when_eq(in float x, in float y)
{
	return 1.0 - abs(sign(x - y));
}

float when_neq(in float x, in float y)
{
	return abs(sign(x - y));
}

vec3 jitter(in vec3 d, in float phi, in float sina, in float cosa)
{
	const vec3 w = normalize(d);
	const vec3 u = normalize(cross(w.yzx, w));
	const vec3 v = cross(w, u);

	return (u * cos(phi) + v * sin(phi)) * sina + w * cosa;
}

vec3 reflect(in Ray ray, in vec3 N)
{
	return ray.dir - 2.0 * dot(N, ray.dir) * N;
}

float calc_sphere_intersect(in Ray ray, in Sphere sphere)
{
	const vec3  oc = ray.origin - sphere.P;
	const float b  = 2.0 * dot(oc, ray.dir);
	const float c  = dot(oc, oc) - sphere.r * sphere.r;
	const float h  = b * b - 4.0 * c;

	if (h < 0.0)
	{
		return -1.0;
	}

	const float t = (-b - sqrt(h)) / 2.0;

	return t;
}

float calc_plane_intersect(in Ray ray, in Plane plane)
{
	float d = dot(ray.dir, plane.N);

	float dist = -(plane.len + dot(ray.origin, plane.N)) / d;

	return when_neq(d, 0.0) * max(dist, 0.0);
}

bool trace_ray(in Ray ray, inout Intersection intersect)
{
	bool found = false;

	for (uint i = 0; i < SPHERE_COUNT; ++i)
	{
		const float t = calc_sphere_intersect(ray, spheres[i]);

		if ((t > EPSILON) && (t < intersect.t + EPSILON))
		{
			intersect.mat = spheres[i].mat;

			intersect.t = t;
			intersect.P = ray.origin + t * ray.dir;
			intersect.N = (intersect.P - spheres[i].P) / spheres[i].r;

			found = true;
		}
	}

	for (uint i = 0; i < PLANE_COUNT; ++i)
	{
		const float t = calc_plane_intersect(ray, planes[i]);

		if ((t > EPSILON) && (t < intersect.t - EPSILON))
		{
			intersect.mat = planes[i].mat;

			intersect.t = t;
			intersect.P = ray.origin + t * ray.dir;
			intersect.N = planes[i].N;

			found = true;
		}
	}

	return found;
}

vec3 radiance(in Ray ray)
{
	vec3 acc  = { 0.0, 0.0, 0.0 };
	vec3 mask = { 1.0, 1.0, 1.0 };

	for (uint depth = 0; depth < DEPTH; ++depth)
	{
		acc = clamp(acc, vec3(0.0), vec3(1.0));

		Intersection intersect;
		intersect.t = 3000 / pow(depth + 1, 3);
		if (trace_ray(ray, intersect) == false) break;

		Material mat = intersect.mat;

		switch (mat.type)
		{
			case MAT_TYPE_DIFFUSE:
			{
				const float r2 = rand();
				const vec3  d  = jitter(intersect.N, 2.0 * PI * rand(), sqrt(r2), sqrt(1.0 - r2));

				vec3  e = { 0.0, 0.0, 0.0 };

				for (uint i = 0; i < SPHERE_COUNT; ++i)
				{
					Sphere s = spheres[i];

					if (s.mat.emissive == vec3(0.0)) continue;

					const float t = length(s.P - intersect.P) - s.r;

					const vec3  l0        = s.P - intersect.P;
					const float cos_a_max = sqrt(1.0 - clamp(s.r * s.r / dot(l0, l0), 0.0, 1.0));
					const float cosa      = mix(cos_a_max, 1.0, rand());
					const vec3  L         = jitter(l0, 2.0 * PI * rand(), sqrt(1.0 - cosa * cosa), cosa);

					const vec3 attenuation = s.mat.emissive / (pow((t / (s.r)) + 1, 2));

					Intersection shadow_intersection;
					shadow_intersection.t = t;
					if (trace_ray(Ray(intersect.P, L), shadow_intersection) == false)
					{
						const float omega = 2.0 * PI * (1.0 - cos_a_max);

						const vec3  R = reflect(ray.dir, intersect.N);

						const float specular = pow(max(dot(R, L), 0.0), 32.0);
						const float diffuse  = dot(L, intersect.N);

						e += attenuation * (s.mat.emissive * clamp(diffuse + specular, 0.0, 1.0 / omega) * omega) / PI;
					}
				}

				acc  += 1 * mask * mat.emissive + mask * mat.albedo * e;
				mask *= (1.0 / (depth + 1)) * mat.albedo;
				ray   = Ray(intersect.P, d);
				break;
			}
			case MAT_TYPE_REFLECT:
			{
				acc  += mat.emissive * mask;
				mask *= mat.albedo;

				ray   = Ray(intersect.P, reflect(ray.dir, intersect.N));
				break;
			}
		}
	}

	return acc;
}



void main()
{
	// Compute camera coordinates and ray direction

	const ivec2 render_target_size = imageSize(render_target);

	const vec2 uv = vec2(gl_GlobalInvocationID.xy) / render_target_size;

	const vec2 trans = 2.0 * uv - vec2(1.0, 1.0);

    const vec3 dir = (camera.dir + camera.right * trans.x + camera.up * trans.y) * vec2(aspect_ratio, 1.0).xyx;

	rand_salt = dir.x / dir.y + uv.x / uv.y + seed;

	// Shoot rays and compute final pixel color

	Ray primary_ray = { camera.pos, normalize(dir) };

	vec3 accum = { 0.0, 0.0, 0.0 };

	for (uint i = 0; i < SAMPLES; ++i)
	{
		accum += radiance(primary_ray);
	}

	// Store our traced pixel

	accum.rgb /= SAMPLES;

	accum.rgb = accum.rgb / (accum.rgb + vec3(1.0));
	accum.rgb = pow(accum.rgb, vec3(1.0 / 2.2));

	const vec3 dithered_color = accum + rand() / 64.0;

	imageStore(render_target, ivec2(gl_GlobalInvocationID.xy), vec4(dithered_color, 1.0));
}
