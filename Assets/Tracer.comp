/**
 * @author Seth Traman
 * @date   2019 03 04
 *
 * @file   Tracer.comp
 * @brief  Updated raytracing compute shader
 */



#version 460

#extension GL_ARB_separate_shader_objects : enable



/**
 * @struct Camera
 *
 * @brief Represents the viewport which is recieving light from the scene
 */
struct Camera
{
	/// @brief Position of the camera in world-space
	vec3 pos;

	/// @brief Normalized direction vector that the camera is viewing
	vec3 dir;

	/// @brief Normalized right-facing direction relative to view direction
	vec3 right;

	/// @brief Normalized up-facing direction relative to view direction
	vec3 up;
};

/**
 * @struct Ray
 *
 * @brief A three-dimentional half-line which may intersect with other geometric primitives
 */
struct Ray
{
	/// @brief Position where the ray originates in world-space
	vec3 origin;

	/// @brief Normalized direction vector that the ray is shooting
	vec3 dir;
};

const uint MATERIAL_TYPE_DIFFUSE    = 0;
const uint MATERIAL_TYPE_REFLECTIVE = 1;

struct Material
{
	vec3 albedo;

	vec3 emissive;

	uint type;
};

/**
 * @struct Intersection
 *
 * @brief Information about intersection between a ray and a geometric primitive
 *
 * @see Ray
 */
struct Intersection
{
	Material mat;

	/// @brief Distance from ray origin which intersection occured
	float t;

	/// @brief Position of ray intersection in world-space
	vec3 P;

	/// @brief Normal of surface patch which ray collided with
	vec3 N;
};

/**
 * @struct Light
 *
 * @brief Point light, creator of photons, illuminator of worlds
 */
struct Light
{
	/// @brief Position of light in world-space
	vec3 P;

	/// @brief RGB color of photons emitted from light
	vec3 color;
};

/**
 * @struct Sphere
 *
 * @brief Like a ball, but somehow rounder
 */
struct Sphere
{
	Material mat;

	/// @brief Position of sphere in world-space
	vec3 P;

	/// @brief Radius of the sphere
	float r;
};

/**
 * @struct Plane
 *
 * @brief Flatt primitive which stretches into the   v o i d
 */
struct Plane
{
	Material mat;

	vec3 N;

	float len;
};



layout (local_size_x = 16, local_size_y = 16) in;

layout (set = 0, binding = 0, rgba8) uniform writeonly image2D render_target;

layout (push_constant) uniform FrameData
{
	/// @brief Width-height ratio of rendering media
	float aspect_ratio;

	float seed;

	/// @brief Position of the light source in world space
	vec3 light_pos;

	/// @brief Camera viewport object
	/// @see Camera
	Camera camera;
};



const float PI      = 3.14159265359;
const float EPSILON = 1e-3;

const float DEPTH   = 3;
const float SAMPLES = 64;

const uint LIGHT_COUNT  = 1;
const uint SPHERE_COUNT = 3;
const uint PLANE_COUNT  = 5;

const Material white_floor = { vec3(1.0, 1.0, 1.0),    vec3(0.0), MATERIAL_TYPE_DIFFUSE };
const Material red_wall    = { vec3(0.75, 0.25, 0.25), vec3(0.0), MATERIAL_TYPE_DIFFUSE };
const Material green_wall  = { vec3(0.25, 0.75, 0.25), vec3(0.0), MATERIAL_TYPE_DIFFUSE };
const Material blue_wall   = { vec3(0.25, 0.25, 0.75), vec3(0.0), MATERIAL_TYPE_DIFFUSE };
const Material red_metal   = { vec3(0.75, 0.25, 0.25), vec3(0.0), MATERIAL_TYPE_DIFFUSE };
const Material blue_metal  = { vec3(0.25, 0.25, 0.75), vec3(30.0), MATERIAL_TYPE_DIFFUSE };

Light lights[LIGHT_COUNT] =
{
	{ vec3(44.0, 128.3, 24.0), vec3(16000.0, 16000.0, 16000.0) }
};

Sphere spheres[SPHERE_COUNT] =
{
	{ red_metal,  vec3(16.0, 16.3, 16.0), 16.0 },
	{ blue_metal, vec3(0.0, 128.0 - 12.0, 0.0), 12.0 },
	{ red_metal,  vec3(-12.0, 12.3, 24.0), 12.0 }
};

Plane planes[PLANE_COUNT] =
{
	{ white_floor, vec3(0.0, 1.0, 0.0), 0.0 },
	{ white_floor, vec3(0.0, -1.0, 0.0), 128.0 },
	{ red_wall,    vec3(1.0, 0.0, 0.0), 64.0 },
	{ green_wall,  vec3(0.0, 0.0, -1.0), 64.0 },
	{ blue_wall,   vec3(-1.0, 0.0, 0.0), 64.0 }
};



float rand(in vec2 co)
{
	return fract(sin(dot(co + seed, vec2(12.9898, 78.233))) * 43758.5453);
}

float rand_salt = 0.0;

float rand() { return fract(sin(++rand_salt) * 43758.5453123); }

vec3 jitter(in vec3 d, in float phi, in float sina, in float cosa)
{
	const vec3 w = normalize(d);
	const vec3 u = normalize(cross(w.yzx, w));
	const vec3 v = cross(w, u);

	return (u * cos(phi) + v * sin(phi)) * sina + w * cosa;
}

vec3 reflect(in Ray ray, in vec3 N)
{
	return ray.dir - 2.0 * dot(N, ray.dir) * N;
}

float calc_sphere_intersect(in Ray ray, in Sphere sphere)
{
	const vec3  oc = ray.origin - sphere.P;
	const float b  = 2.0 * dot(oc, ray.dir);
	const float c  = dot(oc, oc) - sphere.r * sphere.r;
	const float h  = b * b - 4.0 * c;

	if (h < 0.0)
	{
		return -1.0;
	}

	const float t = (-b - sqrt(h)) / 2.0;

	return t;
}

float calc_plane_intersect(in Ray ray, in Plane plane)
{
	float d = dot(ray.dir, plane.N);

	if (d == 0.0)
	{
		return 0.0;
	}

	float dist = -(plane.len + dot(ray.origin, plane.N)) / d;

	return max(dist, 0.0);
}

bool trace_ray(in Ray ray, inout Intersection intersect)
{
	bool found = false;

	for (uint i = 0; i < SPHERE_COUNT; ++i)
	{
		const float t = calc_sphere_intersect(ray, spheres[i]);

		if ((t > EPSILON) && (t < intersect.t - EPSILON))
		{
			intersect.mat = spheres[i].mat;

			intersect.t = t;
			intersect.P = ray.origin + t * ray.dir;
			intersect.N = (intersect.P - spheres[i].P) / spheres[i].r;

			found = true;
		}
	}

	for (uint i = 0; i < PLANE_COUNT; ++i)
	{
		const float t = calc_plane_intersect(ray, planes[i]);

		if ((t > EPSILON) && (t < intersect.t - EPSILON))
		{
			intersect.mat = planes[i].mat;

			intersect.t = t;
			intersect.P = ray.origin + t * ray.dir;
			intersect.N = planes[i].N;

			found = true;
		}
	}

	return found;
}

vec3 radiance(in Ray ray)
{
	vec3 acc  = { 0.0, 0.0, 0.0 };
	vec3 mask = { 1.0, 1.0, 1.0 };

	for (uint depth = 0; depth < DEPTH; ++depth)
	{
		Intersection intersect;
		intersect.t = 1000;
		if (trace_ray(ray, intersect) == false) break;

		Material mat = intersect.mat;

		const float r2 = rand();
		const vec3  d  = jitter(intersect.N, 2.0 * PI * rand(), sqrt(r2), sqrt(1.0 - r2));

		vec3  e = { 0.0, 0.0, 0.0 };

		for (uint i = 0; i < SPHERE_COUNT; ++i)
		{
			Sphere s = spheres[i];

			if (s.mat.emissive == vec3(0.0)) continue;

			const float t = length(s.P - intersect.P);

			const vec3  l0        = s.P - intersect.P;
			const float cos_a_max = sqrt(1.0 - clamp(s.r * s.r / dot(l0, l0), 0.0, 1.0));
			const float cosa      = mix(cos_a_max, 1.0, rand());
			const vec3  l         = jitter(l0, 2.0 * PI * rand(), sqrt(1.0 - cosa * cosa), cosa);

			Intersection shadow_intersection;
			shadow_intersection.t = t;
			if (trace_ray(Ray(intersect.P, l), shadow_intersection) == false)
			{
				const float omega = 2.0 * PI * (1.0 - cos_a_max);
				e += (s.mat.emissive * clamp(dot(l, intersect.N),0.0,1.0) * omega) / PI;
			}
		}

		acc  += mask * mat.emissive * 1.0 + mask * mat.albedo * e;
		mask *= mat.albedo;
		ray   = Ray(intersect.P, d);
	}

	return acc;
}



void main()
{
	// Compute camera coordinates and ray direction

	const ivec2 render_target_size = imageSize(render_target);

	const vec2 uv = vec2(gl_GlobalInvocationID.xy) / render_target_size;

	const vec2 trans = 2.0 * uv - vec2(1.0, 1.0);

    const vec3 dir = (camera.dir + camera.right * trans.x + camera.up * trans.y) * vec2(aspect_ratio, 1.0).xyx;

	rand_salt = dir.x / dir.y + uv.x / uv.y + seed;

	// Shoot rays and compute final pixel color

	Ray primary_ray = { camera.pos, normalize(dir) };

	vec3 accum = { 0.0, 0.0, 0.0 };

	for (uint i = 0; i < SAMPLES; ++i)
	{
		accum += radiance(primary_ray);
	}

	// Store our traced pixel

	accum.rgb /= SAMPLES;

	accum.rgb = accum.rgb / (accum.rgb + vec3(1.0));
	accum.rgb = pow(accum.rgb, vec3(1.0 / 2.2));

	const vec3 dithered_color = accum + rand() / 64.0;

	imageStore(render_target, ivec2(gl_GlobalInvocationID.xy), vec4(dithered_color, 1.0));
}
